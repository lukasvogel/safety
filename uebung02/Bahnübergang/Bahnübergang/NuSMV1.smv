
MODULE _VARS
	VAR
		V_FailureBrakes : {L_FailureBrakesNo, L_FailureBrakesYes};
		V_FailureSMotor : {L_FailureSMotorNo, L_FailureSMotorYes};
		V_FaultHodometer : {L_FaultHodometerNo, L_FaultHodometerYes};
		V_FaultSecured : {L_FaultSecuredNo, L_FaultSecuredYes};
		V_FaultSensor : {L_FaultSensorNo, L_FaultSensorYes};
		V_FaultTimer : {L_FaultTimerNo, L_FaultTimerYes};
		V_Hodometer : {L_Calc};
		V_ReportedPosition : 0..120;
		V_ReportedSpeed : 0..5;
		V_Geschwindigkeit : 0..5;
		V_Position : 0..120;
		V_KommEinheitUebergang : {L_WarteAufAnfrage, L_Sichere, L_Gesichert, L_Oeffne};
		V_KanalZuZug : {L_IstGesichert, L_Nil};
		V_KanalZuUeb : {L_BitteSichern, L_BitteUmBest, L_Nil};
		V_SUeberfahrtSensor : {L_UeberfahrtOffen, L_UeberfahrtZu};
		V_SAnschlagssensor : {L_SchrankeUnten, L_SchrankeOben, L_KeinKontakt};
		V_Timer : {L_TimerIdle, L_TimerCounting, L_TimerTriggered};
		V_KommEinheitZug : {L_Idle, L_WarteAufBest, L_KeineBestErhalten, L_BestErhalten};
		V_SchrankenWinkel : {0, 45, 90};
		V_Schranke : {L_Existiere};
		V_SMotor : {L_SMotorAus, L_SMotorSchliesse, L_SMotorOeffne};
		V_Countdown : 0..100;
		V_Zug : {L_Fahrend, L_Stehend};
		V_Zugnotbremse : {L_NotbremseAus, L_NotbremseEin};
MODULE _P_FailureBrakes(v)
	INIT
		(v.V_FailureBrakes = L_FailureBrakesNo) & (TRUE)
	TRANS
		 ( v.V_FailureBrakes = L_FailureBrakesNo & next(v.V_FailureBrakes) = L_FailureBrakesYes & TRUE & (TRUE))  |
		 ( v.V_FailureBrakes = L_FailureBrakesNo & next(v.V_FailureBrakes) = L_FailureBrakesNo & TRUE & (TRUE))  |
		 ( v.V_FailureBrakes = L_FailureBrakesYes & next(v.V_FailureBrakes) = L_FailureBrakesYes & TRUE & (TRUE));
MODULE _P_FailureSMotor(v)
	INIT
		(v.V_FailureSMotor = L_FailureSMotorNo) & (TRUE)
	TRANS
		 ( v.V_FailureSMotor = L_FailureSMotorNo & next(v.V_FailureSMotor) = L_FailureSMotorYes & TRUE & (TRUE))  |
		 ( v.V_FailureSMotor = L_FailureSMotorNo & next(v.V_FailureSMotor) = L_FailureSMotorNo & TRUE & (TRUE))  |
		 ( v.V_FailureSMotor = L_FailureSMotorYes & next(v.V_FailureSMotor) = L_FailureSMotorYes & TRUE & (TRUE));
MODULE _P_FaultHodometer(v)
	INIT
		(v.V_FaultHodometer = L_FaultHodometerNo) & (TRUE)
	TRANS
		 ( v.V_FaultHodometer = L_FaultHodometerNo & next(v.V_FaultHodometer) = L_FaultHodometerYes & TRUE & (TRUE))  |
		 ( v.V_FaultHodometer = L_FaultHodometerNo & next(v.V_FaultHodometer) = L_FaultHodometerNo & TRUE & (TRUE))  |
		 ( v.V_FaultHodometer = L_FaultHodometerYes & next(v.V_FaultHodometer) = L_FaultHodometerNo & TRUE & (TRUE))  |
		 ( v.V_FaultHodometer = L_FaultHodometerYes & next(v.V_FaultHodometer) = L_FaultHodometerYes & TRUE & (TRUE));
MODULE _P_FaultSecured(v)
	INIT
		(v.V_FaultSecured = L_FaultSecuredNo) & (TRUE)
	TRANS
		 ( v.V_FaultSecured = L_FaultSecuredNo & next(v.V_FaultSecured) = L_FaultSecuredYes & TRUE & (TRUE))  |
		 ( v.V_FaultSecured = L_FaultSecuredNo & next(v.V_FaultSecured) = L_FaultSecuredNo & TRUE & (TRUE))  |
		 ( v.V_FaultSecured = L_FaultSecuredYes & next(v.V_FaultSecured) = L_FaultSecuredNo & TRUE & (TRUE))  |
		 ( v.V_FaultSecured = L_FaultSecuredYes & next(v.V_FaultSecured) = L_FaultSecuredYes & TRUE & (TRUE));
MODULE _P_FaultSensor(v)
	INIT
		(v.V_FaultSensor = L_FaultSensorNo) & (TRUE)
	TRANS
		 ( v.V_FaultSensor = L_FaultSensorNo & next(v.V_FaultSensor) = L_FaultSensorYes & TRUE & (TRUE))  |
		 ( v.V_FaultSensor = L_FaultSensorNo & next(v.V_FaultSensor) = L_FaultSensorNo & TRUE & (TRUE))  |
		 ( v.V_FaultSensor = L_FaultSensorYes & next(v.V_FaultSensor) = L_FaultSensorNo & TRUE & (TRUE))  |
		 ( v.V_FaultSensor = L_FaultSensorYes & next(v.V_FaultSensor) = L_FaultSensorYes & TRUE & (TRUE));
MODULE _P_FaultTimer(v)
	INIT
		(v.V_FaultTimer = L_FaultTimerNo) & (TRUE)
	TRANS
		 ( v.V_FaultTimer = L_FaultTimerNo & next(v.V_FaultTimer) = L_FaultTimerYes & TRUE & (TRUE))  |
		 ( v.V_FaultTimer = L_FaultTimerNo & next(v.V_FaultTimer) = L_FaultTimerNo & TRUE & (TRUE))  |
		 ( v.V_FaultTimer = L_FaultTimerYes & next(v.V_FaultTimer) = L_FaultTimerYes & TRUE & (TRUE));
MODULE _P_Hodometer(v)
	INIT
		(v.V_Hodometer = L_Calc) & (((v.V_ReportedPosition = (v.V_Position + v.V_Geschwindigkeit)) & (v.V_ReportedSpeed = v.V_Geschwindigkeit)))
	TRANS
		 ( v.V_Hodometer = L_Calc & next(v.V_Hodometer) = L_Calc & ((v.V_Position + v.V_Geschwindigkeit) <= 120) & (next(v.V_ReportedPosition) = (v.V_Position + v.V_Geschwindigkeit) & next(v.V_ReportedSpeed) = v.V_Geschwindigkeit))  |
		 ( v.V_Hodometer = L_Calc & next(v.V_Hodometer) = L_Calc & !((v.V_Position + v.V_Geschwindigkeit) <= 120) & (next(v.V_ReportedPosition) = v.V_ReportedPosition & next(v.V_ReportedSpeed) = v.V_ReportedSpeed));
MODULE _P_KommEinheitUebergang(v)
	INIT
		(v.V_KommEinheitUebergang = L_WarteAufAnfrage) & ((v.V_KanalZuZug = L_Nil))
	TRANS
		 ( v.V_KommEinheitUebergang = L_WarteAufAnfrage & next(v.V_KommEinheitUebergang) = L_Sichere & ((v.V_FaultSecured = L_FaultSecuredNo) & (v.V_KanalZuUeb = L_BitteSichern)) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_WarteAufAnfrage & next(v.V_KommEinheitUebergang) = L_Gesichert & ((v.V_FaultSecured != L_FaultSecuredNo) & (v.V_KanalZuUeb = L_BitteSichern)) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_Sichere & next(v.V_KommEinheitUebergang) = L_Gesichert & (v.V_SAnschlagssensor = L_SchrankeUnten) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_Gesichert & next(v.V_KommEinheitUebergang) = L_Oeffne & ((v.V_SUeberfahrtSensor = L_UeberfahrtZu) | (v.V_Timer = L_TimerTriggered)) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_Gesichert & next(v.V_KommEinheitUebergang) = L_Gesichert & (v.V_KanalZuUeb = L_BitteUmBest) & (next(v.V_KanalZuZug) = L_IstGesichert))  |
		 ( v.V_KommEinheitUebergang = L_WarteAufAnfrage & next(v.V_KommEinheitUebergang) = L_WarteAufAnfrage & (!((v.V_FaultSecured = L_FaultSecuredNo) & (v.V_KanalZuUeb = L_BitteSichern)) & !((v.V_FaultSecured != L_FaultSecuredNo) & (v.V_KanalZuUeb = L_BitteSichern))) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_Sichere & next(v.V_KommEinheitUebergang) = L_Sichere & !(v.V_SAnschlagssensor = L_SchrankeUnten) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_Gesichert & next(v.V_KommEinheitUebergang) = L_Gesichert & (!((v.V_SUeberfahrtSensor = L_UeberfahrtZu) | (v.V_Timer = L_TimerTriggered)) & !(v.V_KanalZuUeb = L_BitteUmBest)) & (next(v.V_KanalZuZug) = v.V_KanalZuZug))  |
		 ( v.V_KommEinheitUebergang = L_Oeffne & next(v.V_KommEinheitUebergang) = L_Oeffne & TRUE & (next(v.V_KanalZuZug) = v.V_KanalZuZug));
MODULE _P_KommEinheitZug(v)
	INIT
		(v.V_KommEinheitZug = L_Idle) & ((v.V_KanalZuUeb = L_Nil))
	TRANS
		 ( v.V_KommEinheitZug = L_Idle & next(v.V_KommEinheitZug) = L_Idle & ((v.V_ReportedPosition >= ((((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed)) - (v.V_ReportedSpeed * (2 + v.V_ReportedSpeed)))) & (v.V_ReportedPosition < (((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed)))) & (next(v.V_KanalZuUeb) = L_BitteSichern))  |
		 ( v.V_KommEinheitZug = L_Idle & next(v.V_KommEinheitZug) = L_WarteAufBest & (v.V_ReportedPosition >= (((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed))) & (next(v.V_KanalZuUeb) = L_BitteUmBest))  |
		 ( v.V_KommEinheitZug = L_WarteAufBest & next(v.V_KommEinheitZug) = L_KeineBestErhalten & ((v.V_ReportedPosition >= ((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10)))) & (v.V_KanalZuZug != L_IstGesichert)) & (next(v.V_KanalZuUeb) = v.V_KanalZuUeb))  |
		 ( v.V_KommEinheitZug = L_WarteAufBest & next(v.V_KommEinheitZug) = L_BestErhalten & (((v.V_ReportedPosition >= (((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed))) & (v.V_ReportedPosition <= ((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))))) & (v.V_KanalZuZug = L_IstGesichert)) & (next(v.V_KanalZuUeb) = L_Nil))  |
		 ( v.V_KommEinheitZug = L_Idle & next(v.V_KommEinheitZug) = L_Idle & (!((v.V_ReportedPosition >= ((((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed)) - (v.V_ReportedSpeed * (2 + v.V_ReportedSpeed)))) & (v.V_ReportedPosition < (((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed)))) & !(v.V_ReportedPosition >= (((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed)))) & (next(v.V_KanalZuUeb) = v.V_KanalZuUeb))  |
		 ( v.V_KommEinheitZug = L_WarteAufBest & next(v.V_KommEinheitZug) = L_WarteAufBest & (!((v.V_ReportedPosition >= ((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10)))) & (v.V_KanalZuZug != L_IstGesichert)) & !(((v.V_ReportedPosition >= (((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))) - ((2 * (2 + 2)) * v.V_ReportedSpeed))) & (v.V_ReportedPosition <= ((95 - 2) - ((v.V_ReportedSpeed * v.V_ReportedSpeed) / ((1 * 2) * 10))))) & (v.V_KanalZuZug = L_IstGesichert))) & (next(v.V_KanalZuUeb) = v.V_KanalZuUeb))  |
		 ( v.V_KommEinheitZug = L_KeineBestErhalten & next(v.V_KommEinheitZug) = L_KeineBestErhalten & TRUE & (next(v.V_KanalZuUeb) = v.V_KanalZuUeb))  |
		 ( v.V_KommEinheitZug = L_BestErhalten & next(v.V_KommEinheitZug) = L_BestErhalten & TRUE & (next(v.V_KanalZuUeb) = v.V_KanalZuUeb));
MODULE _P_SAnschlagssensor(v)
	INIT
		(v.V_SAnschlagssensor = L_SchrankeOben) & (TRUE)
	TRANS
		 ( v.V_SAnschlagssensor = L_SchrankeUnten & next(v.V_SAnschlagssensor) = L_KeinKontakt & (v.V_SchrankenWinkel != 0) & (TRUE))  |
		 ( v.V_SAnschlagssensor = L_SchrankeOben & next(v.V_SAnschlagssensor) = L_KeinKontakt & (v.V_SchrankenWinkel != 90) & (TRUE))  |
		 ( v.V_SAnschlagssensor = L_KeinKontakt & next(v.V_SAnschlagssensor) = L_SchrankeOben & (v.V_SchrankenWinkel = 90) & (TRUE))  |
		 ( v.V_SAnschlagssensor = L_KeinKontakt & next(v.V_SAnschlagssensor) = L_SchrankeUnten & (v.V_SchrankenWinkel = 0) & (TRUE))  |
		 ( v.V_SAnschlagssensor = L_SchrankeUnten & next(v.V_SAnschlagssensor) = L_SchrankeUnten & !(v.V_SchrankenWinkel != 0) & (TRUE))  |
		 ( v.V_SAnschlagssensor = L_SchrankeOben & next(v.V_SAnschlagssensor) = L_SchrankeOben & !(v.V_SchrankenWinkel != 90) & (TRUE))  |
		 ( v.V_SAnschlagssensor = L_KeinKontakt & next(v.V_SAnschlagssensor) = L_KeinKontakt & (!(v.V_SchrankenWinkel = 90) & !(v.V_SchrankenWinkel = 0)) & (TRUE));
MODULE _P_Schranke(v)
	INIT
		(v.V_Schranke = L_Existiere) & ((v.V_SchrankenWinkel = 90))
	TRANS
		 ( v.V_Schranke = L_Existiere & next(v.V_Schranke) = L_Existiere & TRUE & (TRUE));
MODULE _P_SMotor(v)
	INIT
		(v.V_SMotor = L_SMotorAus) & (TRUE)
	TRANS
		 ( v.V_SMotor = L_SMotorAus & next(v.V_SMotor) = L_SMotorSchliesse & (((v.V_FailureSMotor = L_FailureSMotorNo) & (v.V_SAnschlagssensor != L_SchrankeUnten)) & (v.V_KommEinheitUebergang = L_Sichere)) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel))  |
		 ( v.V_SMotor = L_SMotorAus & next(v.V_SMotor) = L_SMotorOeffne & (((v.V_FailureSMotor = L_FailureSMotorNo) & (v.V_KommEinheitUebergang = L_Oeffne)) & (v.V_SAnschlagssensor != L_SchrankeOben)) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel))  |
		 ( v.V_SMotor = L_SMotorSchliesse & next(v.V_SMotor) = L_SMotorAus & (v.V_SAnschlagssensor = L_SchrankeUnten) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel))  |
		 ( v.V_SMotor = L_SMotorSchliesse & next(v.V_SMotor) = L_SMotorSchliesse & ((v.V_SAnschlagssensor != L_SchrankeUnten) & (v.V_SchrankenWinkel != 0)) & (next(v.V_SchrankenWinkel) = (v.V_SchrankenWinkel - 45)))  |
		 ( v.V_SMotor = L_SMotorOeffne & next(v.V_SMotor) = L_SMotorAus & (v.V_SAnschlagssensor = L_SchrankeOben) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel))  |
		 ( v.V_SMotor = L_SMotorOeffne & next(v.V_SMotor) = L_SMotorOeffne & ((v.V_SAnschlagssensor != L_SchrankeOben) & (v.V_SchrankenWinkel != 90)) & (next(v.V_SchrankenWinkel) = (v.V_SchrankenWinkel + 45)))  |
		 ( v.V_SMotor = L_SMotorAus & next(v.V_SMotor) = L_SMotorAus & (!(((v.V_FailureSMotor = L_FailureSMotorNo) & (v.V_SAnschlagssensor != L_SchrankeUnten)) & (v.V_KommEinheitUebergang = L_Sichere)) & !(((v.V_FailureSMotor = L_FailureSMotorNo) & (v.V_KommEinheitUebergang = L_Oeffne)) & (v.V_SAnschlagssensor != L_SchrankeOben))) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel))  |
		 ( v.V_SMotor = L_SMotorSchliesse & next(v.V_SMotor) = L_SMotorSchliesse & (!(v.V_SAnschlagssensor = L_SchrankeUnten) & !((v.V_SAnschlagssensor != L_SchrankeUnten) & (v.V_SchrankenWinkel != 0))) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel))  |
		 ( v.V_SMotor = L_SMotorOeffne & next(v.V_SMotor) = L_SMotorOeffne & (!(v.V_SAnschlagssensor = L_SchrankeOben) & !((v.V_SAnschlagssensor != L_SchrankeOben) & (v.V_SchrankenWinkel != 90))) & (next(v.V_SchrankenWinkel) = v.V_SchrankenWinkel));
MODULE _P_SUeberfahrtSensor(v)
	INIT
		(v.V_SUeberfahrtSensor = L_UeberfahrtOffen) & (TRUE)
	TRANS
		 ( v.V_SUeberfahrtSensor = L_UeberfahrtOffen & next(v.V_SUeberfahrtSensor) = L_UeberfahrtZu & ((v.V_Position >= 100) & (v.V_Position <= (100 + 10))) & (TRUE))  |
		 ( v.V_SUeberfahrtSensor = L_UeberfahrtOffen & next(v.V_SUeberfahrtSensor) = L_UeberfahrtZu & (v.V_FaultSensor != L_FaultSensorNo) & (TRUE))  |
		 ( v.V_SUeberfahrtSensor = L_UeberfahrtZu & next(v.V_SUeberfahrtSensor) = L_UeberfahrtOffen & (v.V_Position < 100) & (TRUE))  |
		 ( v.V_SUeberfahrtSensor = L_UeberfahrtZu & next(v.V_SUeberfahrtSensor) = L_UeberfahrtZu & (v.V_FaultSensor != L_FaultSensorNo) & (TRUE))  |
		 ( v.V_SUeberfahrtSensor = L_UeberfahrtOffen & next(v.V_SUeberfahrtSensor) = L_UeberfahrtOffen & (!((v.V_Position >= 100) & (v.V_Position <= (100 + 10))) & !(v.V_FaultSensor != L_FaultSensorNo)) & (TRUE))  |
		 ( v.V_SUeberfahrtSensor = L_UeberfahrtZu & next(v.V_SUeberfahrtSensor) = L_UeberfahrtZu & (!(v.V_Position < 100) & !(v.V_FaultSensor != L_FaultSensorNo)) & (TRUE));
MODULE _P_Timer(v)
	INIT
		(v.V_Timer = L_TimerIdle) & ((v.V_Countdown = 100))
	TRANS
		 ( v.V_Timer = L_TimerIdle & next(v.V_Timer) = L_TimerCounting & (v.V_KommEinheitUebergang = L_Gesichert) & (next(v.V_Countdown) = v.V_Countdown))  |
		 ( v.V_Timer = L_TimerCounting & next(v.V_Timer) = L_TimerCounting & ((v.V_KommEinheitUebergang = L_Gesichert) & (v.V_Countdown > 0)) & (next(v.V_Countdown) = (v.V_Countdown - 1)))  |
		 ( v.V_Timer = L_TimerCounting & next(v.V_Timer) = L_TimerTriggered & (v.V_Countdown = 0) & (next(v.V_Countdown) = v.V_Countdown))  |
		 ( v.V_Timer = L_TimerCounting & next(v.V_Timer) = L_TimerIdle & (v.V_KommEinheitUebergang = L_Oeffne) & (next(v.V_Countdown) = 100))  |
		 ( v.V_Timer = L_TimerCounting & next(v.V_Timer) = L_TimerTriggered & (v.V_FaultTimer != L_FaultTimerNo) & (next(v.V_Countdown) = v.V_Countdown))  |
		 ( v.V_Timer = L_TimerIdle & next(v.V_Timer) = L_TimerIdle & !(v.V_KommEinheitUebergang = L_Gesichert) & (next(v.V_Countdown) = v.V_Countdown))  |
		 ( v.V_Timer = L_TimerCounting & next(v.V_Timer) = L_TimerCounting & (!((v.V_KommEinheitUebergang = L_Gesichert) & (v.V_Countdown > 0)) & (!(v.V_Countdown = 0) & (!(v.V_KommEinheitUebergang = L_Oeffne) & !(v.V_FaultTimer != L_FaultTimerNo)))) & (next(v.V_Countdown) = v.V_Countdown))  |
		 ( v.V_Timer = L_TimerTriggered & next(v.V_Timer) = L_TimerTriggered & TRUE & (next(v.V_Countdown) = v.V_Countdown));
MODULE _P_Zug(v)
	INIT
		(v.V_Zug = L_Fahrend) & (((v.V_Position = 0) & (v.V_Geschwindigkeit > 0)))
	TRANS
		 ( v.V_Zug = L_Fahrend & next(v.V_Zug) = L_Fahrend & ((v.V_Geschwindigkeit > 0) & ((v.V_Position + v.V_Geschwindigkeit) <= 120)) & (next(v.V_Position) = (v.V_Position + v.V_Geschwindigkeit)))  |
		 ( v.V_Zug = L_Fahrend & next(v.V_Zug) = L_Stehend & (v.V_Geschwindigkeit = 0) & (next(v.V_Position) = v.V_Position))  |
		 ( v.V_Zug = L_Stehend & next(v.V_Zug) = L_Fahrend & (((v.V_Geschwindigkeit > 0) & (v.V_Zugnotbremse = L_NotbremseAus)) & ((v.V_Position + v.V_Geschwindigkeit) <= 100)) & (next(v.V_Position) = (v.V_Position + v.V_Geschwindigkeit)))  |
		 ( v.V_Zug = L_Fahrend & next(v.V_Zug) = L_Fahrend & (!((v.V_Geschwindigkeit > 0) & ((v.V_Position + v.V_Geschwindigkeit) <= 120)) & !(v.V_Geschwindigkeit = 0)) & (next(v.V_Position) = v.V_Position))  |
		 ( v.V_Zug = L_Stehend & next(v.V_Zug) = L_Stehend & !(((v.V_Geschwindigkeit > 0) & (v.V_Zugnotbremse = L_NotbremseAus)) & ((v.V_Position + v.V_Geschwindigkeit) <= 100)) & (next(v.V_Position) = v.V_Position));
MODULE _P_Zugnotbremse(v)
	INIT
		(v.V_Zugnotbremse = L_NotbremseAus) & (TRUE)
	TRANS
		 ( v.V_Zugnotbremse = L_NotbremseAus & next(v.V_Zugnotbremse) = L_NotbremseEin & (v.V_KommEinheitZug = L_KeineBestErhalten) & (next(v.V_Geschwindigkeit) = v.V_Geschwindigkeit))  |
		 ( v.V_Zugnotbremse = L_NotbremseEin & next(v.V_Zugnotbremse) = L_NotbremseEin & ((v.V_FailureBrakes = L_FailureBrakesNo) & (v.V_Geschwindigkeit > 0)) & (next(v.V_Geschwindigkeit) = (v.V_Geschwindigkeit - 1)))  |
		 ( v.V_Zugnotbremse = L_NotbremseAus & next(v.V_Zugnotbremse) = L_NotbremseAus & !(v.V_KommEinheitZug = L_KeineBestErhalten) & (next(v.V_Geschwindigkeit) = v.V_Geschwindigkeit))  |
		 ( v.V_Zugnotbremse = L_NotbremseEin & next(v.V_Zugnotbremse) = L_NotbremseEin & !((v.V_FailureBrakes = L_FailureBrakesNo) & (v.V_Geschwindigkeit > 0)) & (next(v.V_Geschwindigkeit) = v.V_Geschwindigkeit));
MODULE main
	VAR
		v : _VARS();
		p_FailureBrakes : _P_FailureBrakes(v);
		p_FailureSMotor : _P_FailureSMotor(v);
		p_FaultHodometer : _P_FaultHodometer(v);
		p_FaultSecured : _P_FaultSecured(v);
		p_FaultSensor : _P_FaultSensor(v);
		p_FaultTimer : _P_FaultTimer(v);
		p_Hodometer : _P_Hodometer(v);
		p_KommEinheitUebergang : _P_KommEinheitUebergang(v);
		p_KommEinheitZug : _P_KommEinheitZug(v);
		p_SAnschlagssensor : _P_SAnschlagssensor(v);
		p_Schranke : _P_Schranke(v);
		p_SMotor : _P_SMotor(v);
		p_SUeberfahrtSensor : _P_SUeberfahrtSensor(v);
		p_Timer : _P_Timer(v);
		p_Zug : _P_Zug(v);
		p_Zugnotbremse : _P_Zugnotbremse(v);




-- ****DEFINITIONS***

DEFINE noFaults := v.V_FailureBrakes = L_FailureBrakesNo
				 & v.V_FailureSMotor = L_FailureSMotorNo
				 & v.V_FaultHodometer = L_FaultHodometerNo
				 & v.V_FaultSecured = L_FaultSecuredNo
				 & v.V_FaultSensor = L_FaultSensorNo
				 & v.V_FaultTimer = L_FaultTimerNo;

DEFINE SP := 100;
DEFINE GP := 95;

-- ****SOLLVERHALTEN****

-- WICHTIGSTE EIGENSCHAFT

-- Der Zug ist niemals auf einem ungesichertem Bahn?bergang
LTLSPEC (G noFaults) -> (G (v.V_Position >= 95 & v.V_Position < SP -> v.V_SAnschlagssensor = L_SchrankeUnten));
LTLSPEC (G noFaults) -> (G (v.V_Position >= 95 & v.V_Position < SP -> v.V_SchrankenWinkel = 0));


-- EIGENSCHAFTEN ?BERGANG

-- Wenn der ?bergang die Sicherungsnachricht erh?lt, ist er irgendwann auch gesichert
LTLSPEC (G noFaults) -> (G v.V_KanalZuUeb = L_BitteSichern -> (F v.V_SAnschlagssensor = L_SchrankeUnten));
LTLSPEC (G noFaults) -> (G v.V_KanalZuUeb = L_BitteSichern -> (F v.V_SchrankenWinkel = 0));

-- Wenn der Bahn?bergang meldet, er sei gesichert, dann ist auch die Schranke unten
LTLSPEC (G noFaults) -> (G (v.V_KommEinheitUebergang = L_Gesichert -> v.V_SAnschlagssensor = L_SchrankeUnten));
LTLSPEC (G noFaults) -> (G (v.V_KommEinheitUebergang = L_Gesichert -> v.V_SchrankenWinkel = 0));

-- Wenn die Schranke unten ist, ist der ?bergang im n?chsten(!) Schritt (wegen Verz?gerung) gesichert
-- oder er war schon gesichert und ?ffent sich wieder
LTLSPEC (G noFaults) -> (G (v.V_SAnschlagssensor = L_SchrankeUnten -> X (v.V_KommEinheitUebergang = L_Gesichert | v.V_KommEinheitUebergang = L_Oeffne)));

-- Der Zug erh?lt die Sicherungsbest?tigung, wenn er sie denn erh?lt, zumindest einmal vor dem Gefahrenpunkt
LTLSPEC (G noFaults) -> (F (v.V_KanalZuZug = L_IstGesichert -> v.V_Position < GP));

-- Am Ende ?ffnet sich der ?bergang immer
LTLSPEC (G noFaults) -> (F v.V_KommEinheitUebergang = L_Oeffne);

-- Die Schranke ist erst offen, dann geschlossen (wenn Zug Sicherung erfr?gt) und am Ende auf jeden Fall wieder offen
LTLSPEC (G noFaults) -> 
		 (G ( v.V_SAnschlagssensor = L_SchrankeOben  U
		 ( v.V_SAnschlagssensor = L_KeinKontakt U
		 (	v.V_SAnschlagssensor = L_SchrankeUnten U
		 ( v.V_SAnschlagssensor = L_KeinKontakt U
		    (v.V_SAnschlagssensor = L_SchrankeOben & v.V_Position > 100))))));

-- Wenn sich die Schranke ?ffnet, ist der Zug hinter dem Gefahrenpunkt oder der Timer ist abgelaufen
LTLSPEC (G noFaults) -> (G ((v.V_SAnschlagssensor = L_SchrankeUnten & X v.V_SAnschlagssensor = L_KeinKontakt) -> (v.V_Countdown = 0 | v.V_Position > SP)));



-- EIGENSCHAFTEN ZUG

-- Der Zug ?berf?hrt immer den ?berfahrtsensor und ist davor nie stehen geblieben
LTLSPEC (G noFaults) -> (G ( v.V_Geschwindigkeit > 0 U v.V_SUeberfahrtSensor = L_UeberfahrtZu));
LTLSPEC (G noFaults) -> (G ( v.V_Geschwindigkeit > 0 U v.V_Position > SP));

-- Der Zug ist irgendwann immer hinter dem Gefahrenpunkt
LTLSPEC (G noFaults) -> (F v.V_Position > SP);

-- Wenn der Zug bremst, kommt er irgendwann auch zum Stehen
LTLSPEC (G noFaults) -> (G (v.V_Zugnotbremse = L_NotbremseEin -> (F v.V_Geschwindigkeit = 0)));


-- ****AD?QUATHEIT DER FEHLER****

-- FailureBreaks
-- Es gibt einen Trace indem der Zug nicht anh?lt obwohl die Notbremse ausl?st